
package net.suobig.effectivejava.createAndDelete;


public class U1StaticFactory {
/*
Static factory метод – метод класса, возвращающий экземпляр этого класса. 
Например, метод возвращающий объект вместо примитива:*/
    public static Boolean valueOf(boolean b) {
        return b ? Boolean.TRUE : Boolean.FALSE;
    }

/*Static factory методы имеют ряд преимуществ:
    1)	они именованные. Конструкторы классов имеют достаточно низкую 
экспрессивную силу, сложно понять что именно они делают кроме
непосредственно создания экземпляра класса. Например Matrix.square(size) 
описывает создание квадратной матрицы значительно лучше нежели Matrix(size) 
А создание единичной матрицы, выразимое с помощью Matrix.identity(size) 
вообще неясно как выразить в конструкторе. К тому же Java не предполагает 
создание нескольких разных конструкторов с одними и теми же параметрами.
Это ограничение можно обойти, меня последовательность параметров, 
но это не слишком хорошая идея.
    2)	В отличие от конструктора, Static factory метод не обязательно 
создает объект при каждом вызове. Он может возвращать уже существующий 
объект, тем самым улучшая производительность и потребление памяти. 
Кроме всего прочего, это позволяет программисту контролировать количество 
экземпляров класса, что, в свою очередь, позволяет создавать классы с одним 
экземпляром (одиночки), классы без экземпляров, классы без одинаковых 
экземпляров (для которых equals() эквивалентно ==) и так далее.
    3)	Static factory может возвращать экземлпяр не только указанного типа,
но и любого типа-наследника. Это позволяет очень гибко управлять реализацией 
тех или иных методов, которые в таком случае реализуются в классе-наследнике. 
При этом пользователю, обращающемуся к классу-родителю, не приходится 
задумываться с каким конкретно наследником он работает.  Например, класс 
java.util.EnumSet не имеет публичных конструкторов, а лишь static factory, 
которая возвращает либо ReguralEnumSet, если размер объекта Enum не превышает 
64, либо JumboEnumSet для остальных случаев. При этом пользователь может 
быть даже не в курсе этого – он работает с EnumSet, даже не догадываясь 
о конкретной реализации. 

Однако существуют недостатки:
    1)	класс без публичных конструкторов не может иметь наследников;
    2)	static factory методы трудно отличить от остальных static методов в 
документации JavaDoc, так как они там никак не выделяются. Можно слегка 
улучшить ситуацию комментированием и использованием определенных имен, 
таких как:
    •	valueOf
    •	of
    •	getInstance
    •	newInstance
    •	getType
    •	newType
Таким образом и конструкторы, и static factory методы имеют свои области 
применения, так что не стоит сразу выбирать публичный конструктор даже не 
задумавшись о static factory.
 */
}
