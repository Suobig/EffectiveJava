/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package net.suobig.effectivejava.ch2_СreateAndDelete;

/*  Финализаторы непредсказуемые, часатую опасны и чаще всего не нужны. 
    
    Основная проблема финализаторов, что с момента окончания использования 
объекта до момента вызова финализатора может пройти неопределенно долгое
время. Огромная ошибка поручать закрытие файла финализатору - файл может
продолжать оставаться открытым (и, как следствие, недоступным другим потокам)
неопределенно длительное время. Программа даже может рухнуть, если из-за 
запаздывания финализатора окажется открыто слишком много файлов. 

    При этом поведение финализатора полностью зависит от того как организован
сборщик мусора в данной конкретной сборке Виртуальной машины. При этом 
спецификация языка не позволяет определить в каком потоке выполняется 
финализатор и управлять его выполнением в ручном режиме. 

    Кроме того, не существует никаких гарантий, что финализаторы вообще будут
выполнены хоть когда-нибудь. Возможно - и даже очень вероятно - что программа
закончит свою работу вообще не выполнив финализаторов

    Общее правило заключается в том, что никакие важные действия не должны быть
поручены финализатору.

    Ко всему прочему, если во время работы финализатора возникает необработанное
исключение (uncaught exception), то выполнение этого финализатора завершается,
а исключение игнорируется. Вполне возможно, что подобное событие оставит в
системе поврежденный объект, приводя к непредсказуемым и труднообнаружимым
последствиям.

    И, в заключение, реализация финализаторов существенно увеличивает время 
создания класса. 

    Выход просто - использовать явный завершающий метод. Главное, чтобы в 
экземпляре хранилась информация о том, что он был завершен и всем клиентам
пытающимся к нему обратиться возвращалась IllegalStateException

    Явное завершение объекта обычно используется вместе с try-finally методами
    
    Есть две причины использовать финализатор:
    1) как систему безопасности на случай, если пользователь забудет вызвать
завершающий метод. Лучше завершить объект позже, чем никогда. Но при этом важно
сделать соответствующую запись в логе, которая предупреждает о некорректном 
использовании объекта. Нужно хорошенько подумать, стоит ли доп.защита доп.
ресурсов, выделяемых на финализатор.

    2) При использовании native библиотек. Так как сборщик мусора не 
работает с объектами из native-библиотек, их время жизни надо контролировать
вручну

    Обратите внимание, что вызов финализатора класса-потомка не влечет за собой
вызов финализатора у его родителя. Его надо прописывать руками:*/
class ParentFinalizer {
    @Override
    protected void finalize() throws Throwable {
        //Завершает объект
    }
}

class ChildFinalizer extends ParentFinalizer {
    @Override
    protected void finalize() throws Throwable {
        try {
            //Завершите данный объек
        } finally {
            super.finalize();
        }
    }
}

